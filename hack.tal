( From NAND to TETRIS in UXNTAL. )

( MACROS )
%:DBG ( -- ) { [ LIT2 -T -System/debug ] DEO }

( STRING MACROS 

  These are used to represent non printable ASCII characters in 
  strings, all string macros begin with \ to emulate string
  interpolation syntax. )
%\n { 0a }  ( newline )
%\0 { 00 }  ( null )
%\s { 20 }  ( space )
%\e { 1b }  ( escape )

( ANSI ESCAPE CODES 

  These are used to stylize the output. )
%\CSI { \e "[ }
%\TERMINATOR { "m }
%\RESET { \CSI \TERMINATOR }
%\TRUE-COLOR { "38;2; }
                           ( R   G   B )
%\GREEN { \CSI \TRUE-COLOR "100;255;100 \TERMINATOR }
%\RED   { \CSI \TRUE-COLOR "255;100;100 \TERMINATOR }

( DEVICES )
|0e @System/debug $1
|18 @Console/write $1

( CONSTANTS )
|00 @F @F16 $1 @T
|ffff @T16
|0000 @F-F
|0001 @F-T
|0100 @T-F
|0101 @T-T

|10 @BUS
|4000 @RAM/SIZE
|4e20 @ROM/START

( STATE )
|000 
@REG
	&A $2 
	&D $2
	&PC $2

( ENTRY POINT )
|100
@on-reset ( -> )
	;ROM/START .REG/PC STZ2
	
	test/gates

	print/newline
	:DBG
	BRK

( ## GATES 

  ### Simple Gates

  Simple gates are implemented as functions that accept boolean byte
  values, .T 1 bit true (01) and .F false (00), although we only 
  really need the zero-th bit. Uxn words are 8 bits and doubles are
  16 bits. )
@nand ( a b -- out ) AND .F EQU JMP2r
@and ( a b -- out ) nand ( >> )
@not ( a -- out ) DUP !nand
@and3 ( a b c ) STH and STHr !and
@or ( a b -- out ) not SWP not !nand
@nor ( a b -- out ) or !not
@xor ( a b -- out ) DUP2 not nand STH SWP not nand STHr !nand
@equ ( a b -- out ) DUP2 not SWP not and STH and STHr !or
@mux ( a b sel -- out ) DUP not STH and STH SWPr STHr and STHr !or
@dmux ( sel -- a b ) 
@zero ( a b -- out ) POP2 .F JMP2r
@one ( a b -- out ) POP2 .T JMP2r
@x ( x y -- out ) POP JMP2r
@y ( x y -- out ) NIP JMP2r
@not-y ( x y -- out ) NIP !not
@not-x ( x y -- out ) POP !not
@not-x-and-y ( x y -- out ) SWP ( >> )
@x-and-not-y ( x y -- out ) not !and
@if-x-then-y ( x y -- out ) SWP ( >> )
@if-y-then-x ( x y -- out ) not !or

( ### Multi-bit Gates

  These are implemented using short (double word) mode opcodes, 
  because Uxn has 64Kib of main RAM, using a byte to represent 
  each bit would be a bad idea, we could also extract each bit and
  iterate->apply to construct a result similar to the HDL language.
  
  However for implementation and performance reasons I thought it
  was redundant and the API just implies working on n-bits, by 
  generalization 16-bits. 

  The inputs and outputs are 16-bits, 16-bits false ;F16 (0000) and 
  16-bits true ;T16 (ffff). )
@nand16 ( a* b* -- out* ) AND2 ;T16 EOR2 JMP2r
@and16 ( a* b* -- out* ) nand16 ( >> )
@not16 ( a* -- out* ) DUP2 !nand16
@or16 ( a* b* -- out* ) not16 SWP2 not16 !nand16
@nor16 ( a* b* -- out* ) or16 !not16
@xor16 ( a* b* -- out* ) 
	OVR2 OVR2 not16 nand16 STH2 SWP2 not16 nand16 STH2r !nand16
@equ16 ( a* b* -- out* ) 
	OVR2 OVR2 not16 SWP2 not16 and16 STH2 and16 STH2r !or16
@mux16 ( a* b* sel* -- out* ) DUP not STH and STH SWPr STHr and STHr !or
@dmux16 ( sel -- a b ) 
@zero16 ( a b -- out ) POP2 POP2 ;F16 JMP2r
@one16 ( a b -- out ) POP2 POP2 ;T16 JMP2r
@x16 ( x y -- out ) POP JMP2r
@y16 ( x y -- out ) NIP JMP2r
@not-y16 ( x y -- out ) NIP !not
@not-x16 ( x y -- out ) POP !not
@not-x-and-y16 ( x y -- out ) SWP ( >> )
@x-and-not-y16 ( x y -- out ) not !and
@if-x-then-y16 ( x y -- out ) SWP ( >> )
@if-y-then-x16 ( x y -- out ) not !or

( TESTS )
@test/assert ( test-number received expected -- )
	EQU ?{ 
		[ LIT2 &failed $2 ] INC2 ,/failed STR2
		;msgs/failed !/result }
	[ LIT2 &passed $2 ] INC2 ,/passed STR2
	;msgs/passed ( >> )
	
	&result ( test-number str* -- ) 
		print/string print/byte-dec !print/newline

@test/summary ( -- )
	print/newline
	
	,/failed LDR2 DUP2 ORA ?{ 
		POP2 ;msgs/success print/string !/continue }
	;msgs/total-failed /report ( >> )
	
	&continue ( -- )
		,/passed LDR2 ;msgs/total-passed ( >> )

	&report ( total* str* -- )
		print/string print/short-dec !print/newline

@test/gates ( -- )
	;msgs/nand print/string
(  TEST #    EVAL        ASSERT    )	
	#01 [ ;F-F nand ] .T /assert
	#02 [ ;F-T nand ] .T /assert
	#03 [ ;T-F nand ] .T /assert
	#04 [ ;T-T nand ] .F /assert

	;msgs/and print/string
	#01 [ ;F-F and ] .F /assert	
	#02 [ ;F-T and ] .F /assert
	#03 [ ;T-F and ] .F /assert
	#04 [ ;T-T and ] .T /assert

	;msgs/not print/string
	#01 [ .F not ] .T /assert
	#02 [ .T not ] .F /assert

	;msgs/or print/string
	#01 [ ;F-F or ] .F /assert
	#02 [ ;F-T or ] .T /assert
	#03 [ ;T-F or ] .T /assert
	#04 [ ;T-T or ] .T /assert

	;msgs/xor print/string
	#01 [ ;F-F xor ] .F /assert
	#02 [ ;F-T xor ] .T /assert
	#03 [ ;T-F xor ] .T /assert
	#04 [ ;T-T xor ] .F /assert

	;msgs/nor print/string
	#01 [ ;F-F nor ] .T /assert
	#02 [ ;F-T nor ] .F /assert
	#03 [ ;T-F nor ] .F /assert
	#04 [ ;T-T nor ] .F /assert

	;msgs/equ print/string
	#01 [ ;F-F equ ] .T /assert
	#02 [ ;F-T equ ] .F /assert
	#03 [ ;T-F equ ] .F /assert
	#03 [ ;T-T equ ] .T /assert

	;msgs/mux print/string
	#01 [ ;F-F .F mux ] .F /assert
	#02 [ ;F-T .F mux ] .F /assert
	#03 [ ;T-F .F mux ] .T /assert
	#04 [ ;T-T .F mux ] .T /assert
	#05 [ ;F-F .T mux ] .F /assert
	#06 [ ;F-T .T mux ] .T /assert
	#07 [ ;T-F .T mux ] .F /assert
	#08 [ ;T-T .T mux ] .T /assert

	;msgs/x-and-not-y print/string
	#01 [ ;F-F x-and-not-y ] .F /assert
	#02 [ ;F-T x-and-not-y ] .F /assert
	#03 [ ;T-F x-and-not-y ] .T /assert
	#04 [ ;T-T x-and-not-y ] .F /assert

	;msgs/not-x-and-y print/string
	#01 [ ;F-F not-x-and-y ] .F /assert
	#02 [ ;F-T not-x-and-y ] .T /assert
	#03 [ ;T-F not-x-and-y ] .F /assert
	#04 [ ;T-T not-x-and-y ] .F /assert

	;msgs/constant-0 print/string
	#01 [ ;F-F zero ] .F /assert
	#02 [ ;F-T zero ] .F /assert
	#03 [ ;T-F zero ] .F /assert
	#04 [ ;T-T zero ] .F /assert

	;msgs/constant-1 print/string
	#01 [ ;F-F one ] .T /assert
	#02 [ ;F-T one ] .T /assert
	#03 [ ;T-F one ] .T /assert
	#04 [ ;T-T one ] .T /assert

	;msgs/x print/string
	#01 [ ;F-F x ] .F /assert
	#02 [ ;F-T x ] .F /assert
	#03 [ ;T-F x ] .T /assert
	#04 [ ;T-T x ] .T /assert

	;msgs/y print/string
	#01 [ ;F-F y ] .F /assert
	#02 [ ;F-T y ] .T /assert
	#03 [ ;T-F y ] .F /assert
	#04 [ ;T-T y ] .T /assert

	;msgs/not-x print/string
	#01 [ ;F-F not-x ] .T /assert
	#02 [ ;F-T not-x ] .T /assert
	#03 [ ;T-F not-x ] .F /assert
	#04 [ ;T-T not-x ] .F /assert
	
	;msgs/not-y print/string
	#01 [ ;F-F not-y ] .T /assert
	#02 [ ;F-T not-y ] .F /assert
	#03 [ ;T-F not-y ] .T /assert
	#04 [ ;T-T not-y ] .F /assert
	
	;msgs/if-x-then-y print/string
	#01 [ ;F-F if-x-then-y ] .T /assert
	#02 [ ;F-T if-x-then-y ] .T /assert
	#03 [ ;T-F if-x-then-y ] .F /assert
	#04 [ ;T-T if-x-then-y ] .T /assert
	
	;msgs/if-y-then-x print/string
	#01 [ ;F-F if-y-then-x ] .T /assert
	#02 [ ;F-T if-y-then-x ] .F /assert
	#03 [ ;T-F if-y-then-x ] .T /assert
	#04 [ ;T-T if-y-then-x ] .T /assert

	!/summary

( STDLIB  )
@print/newline ( -- ) ;msgs/newline ( >> )
@print/string ( zstr* -- ) LDAk #18 DEO INC2 LDAk ?/string POP2 JMP2r
@print/short ( short* -- ) SWP /byte ( >> )
@print/byte ( byte -- ) DUP #04 SFT /nibble ( >> )
@print/nibble ( byte -- ) 
	#0f AND DUP #09 GTH #27 MUL ADD [ LIT "0 ] ADD #18 DEO JMP2r
	
@print/short-dec ( short* -- )
	#000a SWP2 [ LITr ff ]
	&>get ( -- )
		SWP2k DIV2k MUL2 SUB2 STH
		POP OVR2 DIV2 ORAk ?&>get
	POP2 POP2
	&>put ( -- )
		STHr INCk ?{ POP JMP2r }
		[ LIT "0 ] ADD #18 DEO !&>put

@print/byte-dec ( dec -- )
	DUP #64 DIV /try
	DUP #0a DIV /try
	( >> )

@print/number ( num -- )
	#0a DIVk MUL SUB [ LIT "0 ] ADD #18 DEO
	JMP2r
	&try ( num -- )
		DUP ?print/number
		POP JMP2r

( STRINGS )		
@msgs
	&nand "NAND: \n \0
	&and \n "AND: \n \0
	&not \n "NOT: \n \0
	&or \n "OR: \n \0
	&nor \n "NOR: \n \0
	&equ \n "EQU: \n \0
	&xor \n "XOR: \n \0
	&mux \n "MUX: \n \0
	&x-and-not-y \n "X \s "AND \s "NOT \s "Y: \n \0
	&not-x-and-y \n "NOT \s "X \s "AND \s "Y: \n \0
	&constant-0 \n "CONSTANT \s "0: \n \0
	&constant-1 \n "CONSTANT \s "1: \n \0
	&x \n "X: \n \0
	&y \n "Y: \n \0
	&not-x \n "NOT \s "X: \n \0
	&not-y \n "NOT \s "Y: \n \0
	&if-x-then-y \n "IF \s "X \s "THEN \s "Y: \n \0
	&if-y-then-x \n "IF \s "Y \s "THEN \s "X: \n \0
	&passed "- \s \GREEN "PASSED \RESET ": \s "# \0
	&failed "- \s \RED "FAILED \RESET ": \s "# \0
	&success "+ \s \GREEN "SUCCESS! \RESET \n \0
	&total-passed "* \s \GREEN "TOTAL \s "PASSED \RESET ": \s \0
	&total-failed "* \s \RED "TOTAL \s "FAILED \RESET ": \s \0
	&newline \n \0

( HACK RAM )
|ROM/START @ROM
