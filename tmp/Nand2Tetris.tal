( MACROS )
%:DBG ( -- ) { ( print/newline ) [ LIT2 -T -System/debug ] DEO }
%:HLT ( code - ) { .System/state DEO BRK }

( STRING MACROS 

  These are used to represent non printable ASCII characters in 
  strings, all string macros begin with \ to emulate string
  interpolation syntax. )
%\n { 0a }  ( newline )
%\t { 09 }  ( tab )
%\0 { 00 }  ( null )
%\s { 20 }  ( space )
%\e { 1b }  ( escape )

( ANSI ESCAPE CODES 

  These are used to stylize the output. )
%\CSI { \e "[ }
%\TERMINATOR { "m }
%\RESET { \CSI \TERMINATOR }
%\TRUE_COLOR { "38;2; }
                             ( R   G   B )
%\GREEN   { \CSI \TRUE_COLOR "128;255;128 \TERMINATOR }
%\RED     { \CSI \TRUE_COLOR "255;128;128 \TERMINATOR }
%\CYAN    { \CSI \TRUE_COLOR "128;255;255 \TERMINATOR }
%\YELLOW  { \CSI \TRUE_COLOR "255;255;128 \TERMINATOR }
%\MAGENTA { \CSI \TRUE_COLOR "255;128;255 \TERMINATOR }
( DEVICES )
|0e @System/debug $1 &state $1
|18 @Console/write $1
|20 @Screen [
	&vector $2 
	&width $2 
	&height $2 
	&auto $2 
	&x $2 
	&y $2 
	&addr $2 
	&pixel $1 
	&sprite $1 ]

|00	@Error $1 ( generic ) [
	&Division $1
	&StackOverflow $1
	&StackUnderflow $1
	&Overflow $1 ( arithmetic )
	&Value $1
	&Assertion $1
	&Index $1
	&Memory $1
	&Fork $1
	&Child $1
	&File $1
	&Unimplemented $1
	&Interrupt $1
	&EOF $1
	&Syntax $1
	&Type $1
	&Remote $1
	&extend  ( |Error/extend @Error/Foo $1 ... ) ]
( ENUMERATIONS )
@ClockSpeed [
	|00 &fast+4 $1
	|01 &fast+3 $1
	|03 &fast+2 $1
	|07 &fast+1 $1
	|0f &normal $1
	|1f &slow+1 $1
	|3f &slow+2 $1
	|7f &slow+3 $1
	|ff &slow+4 $1 ]
	
( CONSTANTS )
|00 @F @F16 $1 @T
|ffff @T16
|0000 @F_F
|0001 @F_T
|0100 @T_F
|0101 @T_T
|100
@on-reset ( -> )
  ;Clock/timer .Screen/vector DEO2
  .T test/set_verbosity
  test
	BRK
( STDLIB  )
@print/newline ( -- ) ;msgs/newline ( >> )
@print/string ( zstr* -- ) LDAk #18 DEO INC2 LDAk ?/string POP2 JMP2r
@print/magenta ( -- ) ;msgs/magenta !/string
@print/green ( -- ) ;msgs/green !/string
@print/red ( -- ) ;msgs/red !/string
@print/yellow ( -- ) ;msgs/yellow !/string
@print/cyan ( -- ) ;msgs/cyan !/string
@print/reset ( -- ) ;msgs/reset !/string
@print/spacer ( -- ) ;msgs/spacer !/string
@print/short ( short* -- ) SWP /byte ( >> )
@print/byte ( byte -- ) DUP #04 SFT /nibble ( >> )
@print/nibble ( byte -- ) 
	#0f AND DUP #09 GTH #27 MUL ADD [ LIT "0 ] ADD #18 DEO JMP2r
	
@print/short-dec ( short* -- )
	#000a SWP2 [ LITr ff ]
	&>get ( -- )
		SWP2k DIV2k MUL2 SUB2 STH
		POP OVR2 DIV2 ORAk ?&>get
	POP2 POP2
	&>put ( -- )
		STHr INCk ?{ POP JMP2r }
		[ LIT "0 ] ADD #18 DEO !&>put

@print/byte-dec ( dec -- )
	DUP #64 DIV /byte-num-try
	DUP #0a DIV /byte-num-try
	( >> )

@print/byte-num ( num -- )
	#0a DIVk MUL SUB [ LIT "0 ] ADD #18 DEO
	JMP2r
	&byte-num-try ( num -- )
		DUP ?/byte-num
		POP JMP2r
( TESTS )
@test/get_verbosity ( -- f ) [ LIT &verbose $1 ] #00 EQU JMP2r
@test/set_verbosity ( f -- ) ,/verbose STR JMP2r
@test/assert ( test-number flag -- )
	?{ 
		[ LIT2 &failed $2 ] INC2 ,/failed STR2
		;msgs/failed !/result }
	[ LIT2 &passed $2 ] INC2 ,/passed STR2
	/get_verbosity ?{
		;msgs/passed ( >> )
	
		&result ( test-number str* -- )
			/print-id ROT print/magenta print/byte-dec 
			;msgs/spacer print/string !print/string }
	POP JMP2r

@test/summary ( -- )
	,/failed LDR2 STH2k ORA ?{ 
		;msgs/success print/string !/continue }

	STH2kr ;msgs/total-failed /report

	&continue ( | failed* -- )
		,/passed LDR2 STH2k ORA ?{ 
			;msgs/everything-is-fine print/string }

		STH2kr ;msgs/total-passed /report	
		STH2r STH2r ADD2 ;msgs/total-tests /report
		/get_verbosity ?{
			,/sets LDR2 ;msgs/total-sets /report
			,/subsets LDR2 ;msgs/total-subsets !/report }
		JMP2r

@test/report ( total* str* -- ) print/string print/short-dec !print/newline
@test/print-id ( -- )
	,/current-set LDR2 LDA ?{ !/continue_ }
	print/yellow
	,/current-set LDR2 print/string
	print/spacer

	&continue_
		,/current-subset LDR2 LDA ?{ !/end_ }
		print/cyan
		,/current-subset LDR2 print/string
		!print/spacer
		
	&end_ JMP2r

@test/set ( name* -- )
	[ LIT2 &sets $2 ] INC2 ,/sets STR2
	,/current-set STR2
	JMP2r
		&current-set $2

@test/subset ( name* -- )
	[ LIT2 &subsets $2 ] INC2 ,/subsets STR2
	,/current-subset STR2
	JMP2r
		&current-subset $2

@test/end-set ( -- ) ;msgs/null ,/current-set STR2 print/newline ( >> )
@test/end-subset ( -- ) ;msgs/null ,/current-subset STR2 !print/newline

(
test/test ( -- )
	/set: [ "Test \0 ]

	/subset: [ "Standard \0 ]
	( assert true )
	#01 [ #01 #01 EQU ] /assert
	( assert false )
	#02 [ #01 #01 NEQ ] /refute
	( assert error )
	#03 [ #01 #00 DIVs ] .ZeroDivision /failed
	
	/subset: [ "Messages \0 ]
	( assert true with message )
	#01 [#01 #01 EQU ] /assert: [ "True \0 ]
	( assert false with message )
	#02 [ #01 #02 EQU ] /refute: [ "False \0 ]
	( assert error )
	#03 [ #01 #00 DIVs ] /failed: [ "Error \0 ]
	
	/endset

)	

@assert ( -> ) test/assert BRK
@refute

(doc
	@catch ( error:Error -- flag:Bool )
	
Catches an exception by error number, if catched returns F to be used along with
unless blocks.

# Arguments
	- error: error number

# Returns
	- flag: F if catched T otherwise

# Example
	.Error throw 
	.Error catch ?{
		( | suppressed )
		log/string: [ "Divisor \s "can't \s "be \s "zero. \n\0 ]
		( | may be rethrown )
		.Error throw }
		( | last thrown exception exits with error code when a BRK is reached if
		  | not caught )
	BRK		
)
@catch ( error:Error -- flag:Bool ) #0f DEI NEQ ?{ #000f DEO #00 JMP2r } #01 JMP2r
@catch/any ( -- flag:Bool ) #0f DEI ?{ #01 JMP2r } #000f DEO #00 JMP2r

@DIVs ( a b -- c|Error/ZeroDivision )
	DUP ?{ 
		POP2 
		.Error/Division ;/name_ throw  }
	DIV JMP2r
	&name_ [ "DIVs \n \0 ]

( throw and detect later )
@throw ( error -- ) .System/state DEO :DBG JMP2r
@throw! ( error -> (exit) ) throw BRK
@throw: ( error -- ) 

( ## GATES 

  ### Simple Gates

  Simple gates are implemented as functions that accept boolean byte
  values, .T 1 bit true (01) and .F false (00), although we only 
  really need the zero-th bit. Uxn words are 8 bits and doubles are
  16 bits. )
@Nand ( a b -- out ) AND .F EQU JMP2r
@And ( a b -- out ) Nand ( >> )
@Not ( a -- out ) DUP !Nand
@Or ( a b -- out ) Not SWP !if_x_then_y
@Nor ( a b -- out ) Or !Not
@Xor ( a b -- out ) DUP2 Not_x_And_y STH x_And_Not_y STHr !Or
@Mux ( a b sel -- out ) DUP Not STH And STH SWPr STHr And STHr !Or
@DMux ( in sel -- a b ) DUP2 And STH x_And_Not_y STHr JMP2r

%NAND ( a b -- out ) { AND NOT }
%NOT ( a -- out ) { .F EQU }
%OR ( a b -- out ) { ORA }
%NOR ( a b -- out ) { OR NOT }
%XOR ( a b -- out ) { EOR }
%MUX ( a b sel -- out ) { JMP SWP NIP }
%DMUX ( in sel -- a b ) { DUP2k EOR2 ROT EQU JMP SWP }

@Equ ( a b -- out ) Xor !Not
@Zero ( a b -- out ) POP2 .F JMP2r
@One ( a b -- out ) POP2 .T JMP2r
@x ( x y -- out ) POP JMP2r
@y ( x y -- out ) NIP JMP2r
@Not_y ( x y -- out ) y !Not
@Not_x ( x y -- out ) x !Not
@x_And_Not_y ( x y -- out ) Not !And
@Not_x_And_y ( x y -- out ) Not !Nor
@if_x_then_y ( x y -- out ) Not !Nand
@if_y_then_x ( x y -- out ) Not !Or

%3AND ( a b c -- out ) { AND AND }
%ZERO ( a b -- out ) { POP2 .F }
%ONE ( a b -- out ) { POP2 .T }
%X ( a b -- out ) { POP }
%Y ( a b -- out ) { NIP }
%NOT_X ( a b -- out ) { X NOT }
%NOT_Y ( a b -- out ) { Y NOT }
%x_and_not_y ( a b -- out ) { NOT AND }
%not_x_and_y ( a b -- out ) { SWP x_and_not_y }
%IF_X_THEN_Y ( a b -- out ) { NOT NAND }
%IF_Y_THEN_X ( a b -- out ) { SWP if_x_then_y }
 
( ### Multi-bit Gates

  These are implemented using short (double word) mode opcodes, 
  because Uxn has 64Kib of main RAM, using a byte to represent 
  each bit would be a bad idea, we could also extract each bit and
  iterate->apply to construct a result similar to the HDL language.
  
  However for implementation and performance reasons I thought it
  was redundant and the API just implies working on n-bits, by 
  generalization 16-bits. 

  The inputs and outputs are 16-bits, 16-bits false ;F16 (0000) and 
  16-bits true ;T16 (ffff). )
@Nand16 ( a* b* -- out* ) AND2 ;T16 EOR2 JMP2r
@And16 ( a* b* -- out* ) Nand16 ( >> )
@Not16 ( a* -- out* ) DUP2 !Nand16
@Or16 ( a* b* -- out* ) Not16 SWP2 Not16 !Nand16

@16bits/binary ( a* b* gate* -- out* )
	STH2
	[ LIT2r 0800 ]
	&loop
		DUP4 STHkr get/n_n Nand ROT ROT
		INCr GTHkr STHr ?/loop
	POP2r
	
	!collect

@16bits/unary

%NOT16 ( a* -- out* ) { ;T16 EOR2 }
%AND16 ( a* b* -- out* ) { AND2 }
%OR16 ( a* b* -- oet* ) { ORA2 }

@Mux16 ( a* b* sel[0] -- out* )
	DUP2 Not16 STH2 And16 STH2 SWP2r STH2r And16 STH2r !Or16
@DMux16 ( in sel[0] -- a b ) OVR2 OVR2 And16 STH2 x_and_not_y16 STH2r JMP2r

@x_and_not_y16 ( a* b* -- out* ) Not16 !And16

@Or8Way ( 7 6 5 4 3 2 1 0 -- out ) Or Or Or Or Or Or !Or
%OR_8_WAY ( in -- out ) { ;F_T ROT JMP POP NIP }

@Or8Way16 ( 7* 6* 5* 4* 3* 2* 1* 0* -- out* ) 
	Or16 Or16 Or16 Or16 Or16 Or16 !Or16
@Mux4Way16 ( a* b* c* d* sel[0..1]-- out* )
	STHk get/0 Mux16 ROT2 ROT2 STHr get/0 Mux16 STHr get/1 !Mux16
	
@Mux8Way16 ( a* b* c* d* e* f* g* h* sel[0..3] -- out* )
	STHk get/0..1 Mux4Way16
	STH2 ROTr STHkr get/0..1 Mux4Way16
	ROTr ROTr STH2r STHr get/2 !Mux16

@DUP4 OVR2 OVR2 JMP2r
@get ( in n ) 
	DUP #00 EQU ?/0_
	DUP #01 EQU ?/1_
	DUP #02 EQU ?/2_
	DUP #03 EQU ?/3_
	DUP #04 EQU ?/4_
	DUP #05 EQU ?/5_
	DUP #06 EQU ?/6_
	#07 EQU ?/7
	#01 :HLT

@get/n_n ( a b n -- a[n] b[n] ) STHk get SWP STHr get JMP2r  
@get/0_ ( in[0..7] -- out[0] ) POP &0 #01 AND JMP2r
@get/1_ ( in[0..7] -- out[0] ) POP &1 #02 AND #01 SFT JMP2r
@get/0..1 ( sel [0..7] -- out[0..1] ) #03 AND JMP2r
@get/2_ ( in[0..7] -- out[0] ) POP &2 #04 AND #02 SFT JMP2r
@get/3_ ( in[0..7] -- out[0] ) POP &3 #08 AND #03 SFT JMP2r
@get/4_ ( in[0..7] -- out[0] ) POP &4 #10 AND #04 SFT JMP2r
@get/5_ ( in[0..7] -- out[0] ) POP &5 #20 AND #05 SFT JMP2r
@get/6_ ( in[0..7] -- out[0] ) POP &6 #40 AND #06 SFT JMP2r
@get/7 ( in[0..7] -- out[0] ) #80 AND #07 SFT JMP2r

@set ( v in n ) #40 SFT STH SWP STHr SFT ORA JMP2r
@collect ( 7 6 5 4 3 2 1 0 -- out ) 
	[ LIT2r 0800 ] #00 
	&loop 
		STHkr set 
		INCr GTHkr STHr ?/loop
	POP2r JMP2r
	
@set/0 ( flag in[0..7] -- out[0..7] ) ORA JMP2r 
@set/1 ( flag in[0..7] -- out[0..7] ) SWP #10 SFT ORA JMP2r 
@set/2 ( flag in[0..7] -- out[0..7] ) SWP #20 SFT ORA JMP2r 
@set/3 ( flag in[0..7] -- out[0..7] ) SWP #30 SFT ORA JMP2r 
@set/4 ( flag in[0..7] -- out[0..7] ) SWP #40 SFT ORA JMP2r 
@set/5 ( flag in[0..7] -- out[0..7] ) SWP #50 SFT ORA JMP2r 
@set/6 ( flag in[0..7] -- out[0..7] ) SWP #60 SFT ORA JMP2r 
@set/7 ( flag in[0..7] -- out[0..7] ) SWP #70 SFT ORA JMP2r 
@DFF ( in id* -- out ) DUP2 LDA STH STA STHr JMP2r

@Clock/speed-set ( Speed -- ) ,/speed STR JMP2r
@Clock/timer ( -> )
        [ LIT &time $1 ] INCk ,/time STR
        [ LIT &speed $1 ] AND ?{
                !/tick }
        BRK

@Clock/tick ( -> )
    #000f DEO
    ( >> )

    &tock ( -> ) BRK
@msgs
  &total-tests "Total \s "Tests: \t \0
	&total-sets "Total \s "Sets: \t \0
	&total-subsets "Total \s "Subsets: \t \0
	&passed \GREEN "PASSED \RESET \n \0
	&failed \RED "FAILED \RESET \n \0
	&success \GREEN "SUCCESS! \RESET \n \0
	&total-passed \GREEN "Total \s "Passed \RESET ": \t \0
	&total-failed \RED "Total \s "Failed \RESET ": \t \0
	&everything-is-fine 
		\RED "Everything \s "is \s "fine! \RESET \s "üî•üê∂‚òïüî• \n \0
( STRINGS )		
@msgs/gates "Gates \0
	&chips "Chips \0
	&nand "Nand \0
	&and "And \0
	&not "Not \0
	&or "Or \0
	&nor "Nor \0
	&equ "Equ \0
	&xor "Xor \0
	&mux "Mux \0
	&dmux "DMux \0
	&x_and_not_y "x \s "& \s "!y \0
	&not_x_and_y "!x \s "& \s "y \0
	&constant-0 "Zero \0
	&constant-1 "One \0
	&x "x \0
	&y "y \0
	&not-x "!x \0
	&not-y "!y \0
	&if_x_then_y "!x \s "| \s "y \0
	&if_y_then_x "x \s "| \s "!y \0
	&dff "DFF \0
	&srl "SRL \0

	&newline \n \0
	&spacer \RESET ": \t \0
	&cyan \CYAN \0
	&yellow \YELLOW \0
	&magenta \MAGENTA \0
	&green \GREEN \0
	&red \RED \0
	&reset \RESET \0
	&null \0
	@test/gates ( -- )
    ;msgs/gates /set
        
    ;msgs/nand /subset    
        #01 [ ;F_F Nand ] .T EQU /assert
        #02 [ ;F_T Nand ] .T EQU /assert
        #03 [ ;T_F Nand ] .T EQU /assert
        #04 [ ;T_T Nand ] .F EQU /assert

        #05 [ ;F_F Nand ] [ ;F_F NAND ] EQU /assert
        #06 [ ;F_T Nand ] [ ;F_T NAND ] EQU /assert
        #07 [ ;T_F Nand ] [ ;T_F NAND ] EQU /assert
        #08 [ ;T_T Nand ] [ ;T_T NAND ] EQU /assert
    /end-subset

    ;msgs/and /subset
        #01 [ ;F_F And ] .F EQU /assert    
        #02 [ ;F_T And ] .F EQU /assert
        #03 [ ;T_F And ] .F EQU /assert
        #04 [ ;T_T And ] .T EQU /assert

        #05 [ ;F_F And ] [ ;F_F AND ] EQU /assert
        #06 [ ;F_T And ] [ ;F_T AND ] EQU /assert
        #07 [ ;T_F And ] [ ;T_F AND ] EQU /assert
        #08 [ ;T_T And ] [ ;T_T AND ] EQU /assert
    /end-subset
    
    ;msgs/not /subset
        #01 [ .F Not ] .T EQU /assert
        #02 [ .T Not ] .F EQU /assert

        #01 [ .F Not ] [ .F NOT ] EQU /assert
        #02 [ .T Not ] [ .T NOT ] EQU /assert
    /end-subset
    
    ;msgs/or /subset
        #01 [ ;F_F Or ] .F EQU /assert
        #02 [ ;F_T Or ] .T EQU /assert
        #03 [ ;T_F Or ] .T EQU /assert
        #04 [ ;T_T Or ] .T EQU /assert

        #05 [ ;F_F Or ] [ ;F_F OR ] EQU /assert
        #06 [ ;F_T Or ] [ ;F_T OR ] EQU /assert
        #07 [ ;T_F Or ] [ ;T_F OR ] EQU /assert
        #08 [ ;T_T Or ] [ ;T_T OR ] EQU /assert
    /end-subset
    
    ;msgs/xor /subset
        #01 [ ;F_F Xor ] .F EQU /assert
        #02 [ ;F_T Xor ] .T EQU /assert
        #03 [ ;T_F Xor ] .T EQU /assert
        #04 [ ;T_T Xor ] .F EQU /assert

        #05 [ ;F_F Xor ] [ ;F_F XOR ] EQU /assert
        #06 [ ;F_T Xor ] [ ;F_T XOR ] EQU /assert
        #07 [ ;T_F Xor ] [ ;T_F XOR ] EQU /assert
        #08 [ ;T_T Xor ] [ ;T_T XOR ] EQU /assert
    /end-subset
    
    ;msgs/nor /subset
        #01 [ ;F_F Nor ] .T EQU /assert
        #02 [ ;F_T Nor ] .F EQU /assert
        #03 [ ;T_F Nor ] .F EQU /assert
        #04 [ ;T_T Nor ] .F EQU /assert

        #05 [ ;F_F Nor ] [ ;F_F NOR ] EQU /assert
        #06 [ ;F_T Nor ] [ ;F_T NOR ] EQU /assert
        #07 [ ;T_F Nor ] [ ;T_F NOR ] EQU /assert
        #08 [ ;T_T Nor ] [ ;T_T NOR ] EQU /assert
    /end-subset
    
    ;msgs/equ /subset
        #01 [ ;F_F Equ ] .T EQU /assert
        #02 [ ;F_T Equ ] .F EQU /assert
        #03 [ ;T_F Equ ] .F EQU /assert
        #04 [ ;T_T Equ ] .T EQU /assert

        #05 [ ;F_F Equ ] [ ;F_F EQU ] EQU /assert
        #06 [ ;F_T Equ ] [ ;F_T EQU ] EQU /assert
        #07 [ ;T_F Equ ] [ ;T_F EQU ] EQU /assert
        #08 [ ;T_T Equ ] [ ;T_T EQU ] EQU /assert
    /end-subset
    
    ;msgs/mux /subset
        #01 [ ;F_F .F Mux ] .F EQU /assert
        #02 [ ;F_T .F Mux ] .F EQU /assert
        #03 [ ;T_F .F Mux ] .T EQU /assert
        #04 [ ;T_T .F Mux ] .T EQU /assert
        #05 [ ;F_F .T Mux ] .F EQU /assert
        #06 [ ;F_T .T Mux ] .T EQU /assert
        #07 [ ;T_F .T Mux ] .F EQU /assert
        #08 [ ;T_T .T Mux ] .T EQU /assert
    
           #09 [ ;F_F .F Mux ] [ ;F_F .F MUX ] EQU /assert
           #0a [ ;F_T .F Mux ] [ ;F_T .F MUX ] EQU /assert
           #0b [ ;T_F .F Mux ] [ ;T_F .F MUX ] EQU /assert
           #0c [ ;T_T .F Mux ] [ ;T_T .F MUX ] EQU /assert
           #0d [ ;F_F .T Mux ] [ ;F_F .T MUX ] EQU /assert
           #0e [ ;F_T .T Mux ] [ ;F_T .T MUX ] EQU /assert
           #0f [ ;T_F .T Mux ] [ ;T_F .T MUX ] EQU /assert
           #10 [ ;T_T .T Mux ] [ ;T_T .T MUX ] EQU /assert
    /end-subset
    
    ;msgs/dmux /subset
        #01 [ ;T_F DMux ] ;T_F EQU2 /assert
        #02 [ ;F_T DMux ] ;F_F EQU2 /assert

        #03 [ ;T_F DMux ] [ ;T_F DMUX ] EQU2 /assert
        #04 [ ;F_T DMux ] [ ;F_F DMUX ] EQU2 /assert
    /end-subset
    
    ;msgs/x_and_not_y /subset
        #01 [ ;F_F x_And_Not_y ] .F EQU /assert
        #02 [ ;F_T x_And_Not_y ] .F EQU /assert
        #03 [ ;T_F x_And_Not_y ] .T EQU /assert
        #04 [ ;T_T x_And_Not_y ] .F EQU /assert
    /end-subset
    
    ;msgs/not_x_and_y /subset
        #01 [ ;F_F Not_x_And_y ] .F EQU /assert
        #02 [ ;F_T Not_x_And_y ] .T EQU /assert
        #03 [ ;T_F Not_x_And_y ] .F EQU /assert
        #04 [ ;T_T Not_x_And_y ] .F EQU /assert
    /end-subset
    
    ;msgs/constant-0 /subset
        #01 [ ;F_F Zero ] .F EQU /assert
        #02 [ ;F_T Zero ] .F EQU /assert
        #03 [ ;T_F Zero ] .F EQU /assert
        #04 [ ;T_T Zero ] .F EQU /assert
    /end-subset
       
    ;msgs/constant-1 /subset
        #01 [ ;F_F One ] .T EQU /assert
        #02 [ ;F_T One ] .T EQU /assert
        #03 [ ;T_F One ] .T EQU /assert
        #04 [ ;T_T One ] .T EQU /assert
      /end-subset
      
    ;msgs/x /subset
        #01 [ ;F_F x ] .F EQU /assert
        #02 [ ;F_T x ] .F EQU /assert
        #03 [ ;T_F x ] .T EQU /assert
        #04 [ ;T_T x ] .T EQU /assert
    /end-subset
       
    ;msgs/y /subset
        #01 [ ;F_F y ] .F EQU /assert
        #02 [ ;F_T y ] .T EQU /assert
        #03 [ ;T_F y ] .F EQU /assert
        #04 [ ;T_T y ] .T EQU /assert
    /end-subset
      
    ;msgs/not-x /subset
        #01 [ ;F_F Not_x ] .T EQU /assert
        #02 [ ;F_T Not_x ] .T EQU /assert
        #03 [ ;T_F Not_x ] .F EQU /assert
        #04 [ ;T_T Not_x ] .F EQU /assert
    /end-subset
         
    ;msgs/not-y /subset
        #01 [ ;F_F Not_y ] .T EQU /assert
        #02 [ ;F_T Not_y ] .F EQU /assert
        #03 [ ;T_F Not_y ] .T EQU /assert
        #04 [ ;T_T Not_y ] .F EQU /assert
    /end-subset
       
    ;msgs/if_x_then_y /subset
        #01 [ ;F_F if_x_then_y ] .T EQU /assert
        #02 [ ;F_T if_x_then_y ] .T EQU /assert
        #03 [ ;T_F if_x_then_y ] .F EQU /assert
        #04 [ ;T_T if_x_then_y ] .T EQU /assert
    /end-subset

    ;msgs/if_y_then_x /subset
        #01 [ ;F_F if_y_then_x ] .T EQU /assert
        #02 [ ;F_T if_y_then_x ] .F EQU /assert
        #03 [ ;T_F if_y_then_x ] .T EQU /assert
        #04 [ ;T_T if_y_then_x ] .T EQU /assert

    !/end-set

@test ( -- )
    /gates
    /chips
    !/summary
@test/chips ( -- )
	;msgs/chips /set
	;msgs/dff /subset
		#01 [ .T #8000 DFF ] .F EQU /assert
		#02 [ .F #8000 DFF ] .T EQU /assert
		#03 [ .F #8000 DFF ] .F EQU /assert
		#04 [ .T #8000 DFF ] .F EQU /assert
		#05 [ .F #8000 DFF ] .T EQU /assert
	
	(
	;msgs/srl /subset
	#01 [ ;F_F .F srl ] ;F_T EQU2 /assert ( start )
	#02 [ ;T_F .F srl ] ;T_F EQU2 /assert ( set )
	#03 [ ;F_F .F srl ] ;T_F EQU2 /assert ( hold )
	#04 [ ;F_T .F srl ] ;F_T EQU2 /assert ( reset )
	( #05 [ ;T_T .F srl ] .Error/SRL /assert-error ( forbiden ) ) )

	!/end-set
